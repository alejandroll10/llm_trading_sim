"""
News Generation Service

Generates market news using LLM based on PUBLIC market information only.
News is then distributed to agents as InformationType.NEWS signals.

IMPORTANT: This service must ONLY use public market data:
- Prices, volume, trades
- Order book (public depth)
- Dividends that have been paid
- Fundamental value, interest rates
- Round information

It must NOT use:
- Individual agent positions
- Agent cash balances
- Agent reasoning or notes
- Pending unfilled orders
"""

from typing import List, Dict, Any, Optional, Literal
from pydantic import BaseModel, Field, field_validator
from dataclasses import dataclass
import openai
import logging
from dotenv import load_dotenv

from scenarios.base import DEFAULT_LLM_BASE_URL

logger = logging.getLogger(__name__)


# ============================================================================
# Pydantic Schemas for Structured LLM Output
# ============================================================================

class NewsItem(BaseModel):
    """A single news item generated by the LLM"""
    headline: str = Field(..., description="Short, attention-grabbing headline (1 sentence)")
    content: str = Field(..., description="Brief news content explaining the event (2-3 sentences)")
    sentiment: Literal["positive", "negative", "neutral"] = Field(
        ..., description="Overall market sentiment of this news"
    )
    magnitude: Literal["minor", "moderate", "major"] = Field(
        ..., description="How significant is this news for the market"
    )
    affected_stocks: Optional[List[str]] = Field(
        None, description="List of specific stock IDs (e.g. 'TECH', 'ENERGY') affected. Use null for market-wide news."
    )

    @field_validator('affected_stocks', mode='before')
    @classmethod
    def filter_generic_stock_names(cls, v):
        """Convert generic/placeholder stock names to None (market-wide news)"""
        if v is None:
            return None
        if not isinstance(v, list):
            return None

        # Generic names that LLMs tend to hallucinate
        generic_names = {
            'generic stock', 'unnamed stock', 'the stock', 'stock',
            'all', 'market', 'all stocks', 'general market', 'n/a', 'none'
        }

        # Filter out generic names
        real_stocks = [s for s in v if s and s.lower().strip() not in generic_names]

        # Return None if no real stocks remain (treat as market-wide)
        return real_stocks if real_stocks else None


class NewsGenerationOutput(BaseModel):
    """Complete output from news generation LLM call"""
    market_analysis: str = Field(
        ..., description="Brief analysis of current market conditions that informed news generation"
    )
    news_items: List[NewsItem] = Field(
        default_factory=list,
        description="List of news items (0-3 items). Empty list if no newsworthy events."
    )


# ============================================================================
# News Generation Prompt
# ============================================================================

NEWS_SYSTEM_PROMPT = """You are a financial news generator for a simulated stock market.

Your role is to generate realistic market news based on observable market conditions.
You should create news that reflects what would realistically be reported given the market data.

Guidelines:
- Generate 0-3 news items per round based on market activity
- If the market is quiet (stable prices, low volume), generate fewer or no news items
- If there are significant price moves, volume spikes, or notable events, generate relevant news
- News should feel realistic and market-relevant
- Vary sentiment and magnitude based on actual market conditions
- For multi-stock markets, you can generate stock-specific or market-wide news

News types you might generate:
- Price movement reports ("Stock rallies on heavy volume")
- Market analysis ("Trading subdued as investors await signals")
- Dividend announcements (if dividends were just paid)
- Technical observations ("Price breaks through key resistance level")
- Volume observations ("Unusual trading activity detected")
- Market sentiment pieces ("Cautious optimism in today's session")

Remember: Only use the PUBLIC market data provided. Do not invent specific companies,
earnings reports, or external events - keep news focused on observable market dynamics."""


def create_news_user_prompt(context: Dict[str, Any]) -> str:
    """Create the user prompt with public market context (single or multi-stock)"""

    prompt_parts = [
        f"=== MARKET STATE (Round {context['round']} of {context['total_rounds']}) ===\n"
    ]

    # Check if multi-stock
    if context.get('is_multi_stock') and context.get('stocks'):
        prompt_parts.append(f"Number of stocks: {len(context['stocks'])}\n")

        for stock_id, stock_data in context['stocks'].items():
            prompt_parts.append(f"--- {stock_id} ---")
            prompt_parts.append(f"  Price: ${stock_data.get('current_price', 0):.2f}")

            if stock_data.get('previous_price'):
                change = stock_data['current_price'] - stock_data['previous_price']
                pct = (change / stock_data['previous_price']) * 100 if stock_data['previous_price'] > 0 else 0
                prompt_parts.append(f"  Change: ${change:+.2f} ({pct:+.1f}%)")

            if stock_data.get('fundamental_value'):
                premium = ((stock_data['current_price'] / stock_data['fundamental_value']) - 1) * 100
                prompt_parts.append(f"  Fundamental: ${stock_data['fundamental_value']:.2f} ({premium:+.1f}% premium)")

            prompt_parts.append(f"  Volume: {stock_data.get('volume', 0)} shares")

            if stock_data.get('last_dividend'):
                prompt_parts.append(f"  Last Dividend: ${stock_data['last_dividend']:.2f}")

            prompt_parts.append("")  # Blank line between stocks

        prompt_parts.append("=== TASK ===")
        prompt_parts.append("Generate news for the market. You can create:")
        prompt_parts.append("- Market-wide news (affected_stocks=null)")
        prompt_parts.append("- Stock-specific news (affected_stocks=[\"STOCK_ID\"])")
        prompt_parts.append("- Multi-stock news (affected_stocks=[\"STOCK_A\", \"STOCK_B\"])")

    else:
        # Single-stock format (original)
        prompt_parts.append(f"Current Price: ${context['current_price']:.2f}")
        if context.get('previous_price'):
            change = context['current_price'] - context['previous_price']
            pct_change = (change / context['previous_price']) * 100 if context['previous_price'] > 0 else 0
            prompt_parts.append(f"Previous Price: ${context['previous_price']:.2f}")
            prompt_parts.append(f"Price Change: ${change:+.2f} ({pct_change:+.1f}%)")

        # Bid/Ask spread
        if context.get('best_bid') and context.get('best_ask'):
            spread = context['best_ask'] - context['best_bid']
            prompt_parts.append(f"Best Bid: ${context['best_bid']:.2f}, Best Ask: ${context['best_ask']:.2f} (Spread: ${spread:.2f})")

        # Volume
        prompt_parts.append(f"Volume This Round: {context.get('volume', 0)} shares")

        # Fundamental value
        if context.get('fundamental_value'):
            premium = ((context['current_price'] / context['fundamental_value']) - 1) * 100
            prompt_parts.append(f"Fundamental Value: ${context['fundamental_value']:.2f} (Price at {premium:+.1f}% premium)")

        # Recent trades
        if context.get('recent_trades'):
            prompt_parts.append(f"\nRecent Trades: {len(context['recent_trades'])} trades")
            for trade in context['recent_trades'][-3:]:  # Last 3 trades
                prompt_parts.append(f"  - {trade.get('quantity', '?')} shares @ ${trade.get('price', 0):.2f}")

    # Dividend info
    if context.get('last_dividend'):
        prompt_parts.append(f"\nLast Dividend Paid: ${context['last_dividend']:.2f}")

    # Price history summary
    if context.get('price_history') and len(context['price_history']) > 1:
        prices = context['price_history']
        high = max(prices)
        low = min(prices)
        prompt_parts.append(f"\nPrice Range (session): ${low:.2f} - ${high:.2f}")

    # Multi-stock info
    if context.get('stock_id'):
        prompt_parts.insert(1, f"Stock: {context['stock_id']}")

    prompt_parts.append("\n\n=== TASK ===")
    prompt_parts.append("Based on the market conditions above, generate appropriate news items.")
    prompt_parts.append("Generate 0-3 news items. If the market is quiet, an empty list is fine.")

    return "\n".join(prompt_parts)


# ============================================================================
# News Service
# ============================================================================

@dataclass
class NewsServiceConfig:
    """Configuration for news generation"""
    model: str = "gpt-oss-120b"  # Use same model as agents (UF HiPerGator compatible)
    enabled: bool = True
    max_items_per_round: int = 3


class NewsService:
    """Service for generating market news via LLM"""

    def __init__(self, config: NewsServiceConfig = None):
        load_dotenv()
        self.config = config or NewsServiceConfig()

        # Initialize OpenAI client
        if DEFAULT_LLM_BASE_URL:
            self.client = openai.OpenAI(base_url=DEFAULT_LLM_BASE_URL)
        else:
            self.client = openai.OpenAI()

    def generate_news(
        self,
        round_number: int,
        total_rounds: int,
        market_state: Dict[str, Any],
        price_history: Optional[List[float]] = None,
        stock_id: Optional[str] = None,
    ) -> List[NewsItem]:
        """
        Generate news based on public market state.

        Args:
            round_number: Current simulation round
            total_rounds: Total rounds in simulation
            market_state: Observable market state (PUBLIC data only!)
            price_history: List of historical prices
            stock_id: Stock identifier for multi-stock scenarios

        Returns:
            List of NewsItem objects (may be empty)
        """
        if not self.config.enabled:
            return []

        # Prepare PUBLIC-ONLY context
        context = self._prepare_public_context(
            round_number, total_rounds, market_state, price_history, stock_id
        )

        try:
            user_prompt = create_news_user_prompt(context)

            logger.debug(f"[NEWS] Generating news for round {round_number}")

            completion = self.client.beta.chat.completions.parse(
                model=self.config.model,
                messages=[
                    {"role": "system", "content": NEWS_SYSTEM_PROMPT},
                    {"role": "user", "content": user_prompt}
                ],
                response_format=NewsGenerationOutput,
                temperature=0.7,  # Some creativity for varied news
            )

            parsed = completion.choices[0].message.parsed
            news_items = parsed.news_items[:self.config.max_items_per_round]

            logger.info(f"[NEWS] Round {round_number}: Generated {len(news_items)} news items")
            for item in news_items:
                logger.debug(f"[NEWS]   - {item.headline} ({item.sentiment}, {item.magnitude})")

            return news_items

        except Exception as e:
            logger.warning(f"[NEWS] Failed to generate news: {e}")
            return []

    def generate_news_multi_stock(
        self,
        round_number: int,
        total_rounds: int,
        stocks_data: Dict[str, Dict[str, Any]],
    ) -> List[NewsItem]:
        """
        Generate news for multi-stock scenarios (single LLM call for all stocks).

        Args:
            round_number: Current simulation round
            total_rounds: Total rounds in simulation
            stocks_data: Dict of {stock_id: {market_state}} for each stock

        Returns:
            List of NewsItem objects (may include market-wide and stock-specific news)
        """
        if not self.config.enabled:
            return []

        # Prepare multi-stock context
        context = {
            'round': round_number,
            'total_rounds': total_rounds,
            'is_multi_stock': True,
            'stocks': {}
        }

        for stock_id, market_state in stocks_data.items():
            market = market_state.get('market', {})
            fundamental = market_state.get('fundamental', {})
            dividend = market_state.get('dividend', {})

            context['stocks'][stock_id] = {
                'current_price': market.get('price', 0),
                'previous_price': market.get('previous_price'),
                'volume': market.get('volume', 0),
                'best_bid': market.get('best_bid'),
                'best_ask': market.get('best_ask'),
                'fundamental_value': fundamental.get('price'),
                'last_dividend': dividend.get('last_paid_dividend'),
            }

        try:
            user_prompt = create_news_user_prompt(context)

            logger.debug(f"[NEWS] Generating multi-stock news for round {round_number} ({len(stocks_data)} stocks)")

            completion = self.client.beta.chat.completions.parse(
                model=self.config.model,
                messages=[
                    {"role": "system", "content": NEWS_SYSTEM_PROMPT},
                    {"role": "user", "content": user_prompt}
                ],
                response_format=NewsGenerationOutput,
                temperature=0.7,
            )

            parsed = completion.choices[0].message.parsed
            news_items = parsed.news_items[:self.config.max_items_per_round]

            logger.info(f"[NEWS] Round {round_number}: Generated {len(news_items)} multi-stock news items")
            for item in news_items:
                stocks_str = ', '.join(item.affected_stocks) if item.affected_stocks else 'MARKET'
                logger.debug(f"[NEWS]   - [{stocks_str}] {item.headline}")

            return news_items

        except Exception as e:
            logger.warning(f"[NEWS] Failed to generate multi-stock news: {e}")
            return []

    def _prepare_public_context(
        self,
        round_number: int,
        total_rounds: int,
        market_state: Dict[str, Any],
        price_history: Optional[List[float]],
        stock_id: Optional[str],
    ) -> Dict[str, Any]:
        """
        Extract PUBLIC-ONLY information for news generation.

        This is the critical function that ensures we don't leak private info.
        """
        market = market_state.get('market', {})
        fundamental = market_state.get('fundamental', {})
        dividend = market_state.get('dividend', {})

        context = {
            # Round info
            'round': round_number,
            'total_rounds': total_rounds,

            # Price info (PUBLIC)
            'current_price': market.get('price', 0),
            'previous_price': market.get('previous_price'),
            'best_bid': market.get('best_bid'),
            'best_ask': market.get('best_ask'),

            # Volume (PUBLIC)
            'volume': market.get('volume', 0),

            # Trade history (PUBLIC - only executed trades)
            'recent_trades': market.get('trade_history', [])[-5:],

            # Fundamental (PUBLIC in most scenarios)
            'fundamental_value': fundamental.get('price'),

            # Dividend (PUBLIC - only what has been paid)
            'last_dividend': dividend.get('last_paid_dividend'),

            # Price history
            'price_history': price_history or [],

            # Stock ID for multi-stock
            'stock_id': stock_id,
        }

        return context


# ============================================================================
# Utility Functions
# ============================================================================

def format_news_for_prompt(news_items: List[NewsItem]) -> str:
    """Format news items for inclusion in agent prompts"""
    if not news_items:
        return "No significant market news this round."

    lines = ["=== MARKET NEWS ==="]
    for i, item in enumerate(news_items, 1):
        sentiment_emoji = {"positive": "ğŸ“ˆ", "negative": "ğŸ“‰", "neutral": "â¡ï¸"}[item.sentiment]
        magnitude_marker = {"minor": "", "moderate": "âš¡", "major": "ğŸ”¥"}[item.magnitude]

        lines.append(f"\n{i}. {magnitude_marker}{sentiment_emoji} {item.headline}")
        lines.append(f"   {item.content}")
        if item.affected_stocks:
            lines.append(f"   [Affects: {', '.join(item.affected_stocks)}]")

    return "\n".join(lines)
